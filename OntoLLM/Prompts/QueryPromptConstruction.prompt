In our experiments, we utilized a specific prompt setup for the Query Prompt Construction.

The prompt for motor ontology:
Given the following ontology structure:

{
        "nodes": {
          "Motor": {
            "MotorName": "Text"
          },
          "Model": {
            "ModelName": "Text"
          },
          "Location": {
            "LocationName": "Text"
          },
          "Phase": {
            "PhaseName": "Text"
          },
          "Manual": {
            "ManualName": "Text"
          },
          "Question": {
            "ChunkVectorID": "Numeric",
            "ChunkQuestion": "Text"
          }
        },
        "relationtrees": {
          "relations": [
            "(MT:MOTOR)-[hm:hasModel]-(MD:Model)",
            "(MT:MOTOR)-[hl:hasLocation]-(LC:Location)",
            "(MT:MOTOR)-[hm:hasModel]-(MD:Model)-[hp:hasPhase]-(P:Phase)",
            "(MT:MOTOR)-[hm:hasModel]-(MD:Model)-[hm:hasManual]-(M:Manual)",
            "(MT:MOTOR)-[hm:hasModel]-(MD:Model)-[hm:hasManual]-(M:Manual)
            -[hq:hasQuestions]-(C:Question)",
            "(C:Question)-[r:related]-(Q:Question)"
          ]
        }
    }
Here are some example queries:

Natural Query: "Where is motor #ent1 located?"
KG Query: "MATCH (m:Motor {MotorName: '#ent1'})-[:hasLocation]->(loc:Location) 
RETURN loc.LocationName"

Natural Query: "What type is motor #ent1?"
KG Query: "MATCH (m:Motor {MotorName: '#ent1'})-[:hasModel]->(model:Model)-[:hasType]->(type:Type) 
RETURN type.TypeName"

Natural Query: "What phase is motor #ent1?"
KG Query: "MATCH (m:Motor {MotorName: '#ent1'})-[:hasModel]->(model:Model)-[:hasPhase]->(phase:Phase) 
RETURN phase.PhaseName"

Generate a KG query for: What is the location of motor ACME Y2000?
